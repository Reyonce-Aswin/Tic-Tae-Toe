<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Tic-Tac-Toe</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        /* Custom styles for the board grid */
        .board-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            aspect-ratio: 1 / 1; /* Ensures the board is always square */
        }
        .cell {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem; /* Large text for X/O */
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.15s ease-in-out, transform 0.1s;
            user-select: none;
            color: #1f2937; /* Dark gray for symbols */
        }

        .cell:hover:not(.occupied) {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .cell:active:not(.occupied) {
            transform: scale(0.98);
        }

        /* Separators */
        .cell:not(:nth-child(3n)) { border-right: 4px solid #f9fafb; /* Lighter divider for cells */ }
        .cell:nth-child(n+1):nth-child(-n+6) { border-bottom: 4px solid #f9fafb; }

        /* The winning line overlay */
        .winning-line {
            position: absolute;
            background-color: #ef4444; /* Red color for the win line */
            border-radius: 9999px;
            z-index: 10;
            transition: all 0.5s ease-out;
        }

        /* Specific line styles (will be set dynamically by JS) */
        .line-row { height: 8px; width: 100%; top: 50%; left: 0; transform: translateY(-50%); }
        .line-col { width: 8px; height: 100%; top: 0; left: 50%; transform: translateX(-50%); }
        .line-diag-rtl { height: 8px; width: 141.42%; top: 50%; left: 50%; transform: translate(-50%, -50%) rotate(-45deg); }
        .line-diag-ltr { height: 8px; width: 141.42%; top: 50%; left: 50%; transform: translate(-50%, -50%) rotate(45deg); }
        .hidden-line { opacity: 0; }
    </style>
</head>
<body class="bg-gray-900 min-h-screen flex items-center justify-center p-4 font-sans">

    <div id="app" class="w-full max-w-sm mx-auto bg-gray-800 shadow-2xl rounded-xl p-6 flex flex-col items-center">

        <!-- Header -->
        <h1 class="text-3xl font-extrabold text-white mb-6 flex items-center">
            <i data-lucide="grid" class="w-6 h-6 mr-2 text-indigo-400"></i>
            Tic-Tac-Toe
        </h1>

        <!-- 1. Player Name Setup Screen (Initially shown) -->
        <div id="setup-screen" class="w-full">
            <h2 class="text-xl font-semibold text-gray-300 mb-4 text-center">Enter Player Names</h2>
            
            <div class="space-y-4">
                <div class="bg-gray-700 p-3 rounded-lg flex flex-col">
                    <label for="player1-name" class="text-sm font-medium text-indigo-400">Player X (First)</label>
                    <input type="text" id="player1-name" value="Player X" placeholder="Enter name for X" class="mt-1 p-2 w-full bg-gray-600 border border-gray-500 rounded-md text-white focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                
                <div class="bg-gray-700 p-3 rounded-lg flex flex-col">
                    <label for="player2-name" class="text-sm font-medium text-yellow-400">Player O (Second)</label>
                    <input type="text" id="player2-name" value="Player O" placeholder="Enter name for O" class="mt-1 p-2 w-full bg-gray-600 border border-gray-500 rounded-md text-white focus:ring-indigo-500 focus:border-indigo-500">
                </div>
            </div>

            <button id="start-game-button" class="mt-6 w-full px-6 py-3 bg-indigo-600 text-white font-bold rounded-lg shadow-lg hover:bg-indigo-500 transition duration-200 active:scale-95 flex items-center justify-center">
                <i data-lucide="play" class="w-5 h-5 mr-2"></i>
                Start Game
            </button>
        </div>

        <!-- 2. Game Board Screen (Initially hidden) -->
        <div id="game-screen" class="w-full hidden">
            <!-- Status Display -->
            <div id="status-message" class="text-lg font-semibold text-center h-8 mb-4">
                <!-- Content generated by updateStatusMessage() -->
            </div>

            <!-- The Game Board Container -->
            <div id="board-container" class="relative w-full max-w-xs sm:max-w-sm rounded-lg overflow-hidden shadow-xl bg-gray-700 p-2">
                
                <!-- Winning Line Placeholder -->
                <div id="win-line" class="winning-line hidden-line"></div>

                <!-- The Grid -->
                <div id="game-board" class="board-grid border-4 border-gray-700">
                    <!-- Cells will be generated by JavaScript -->
                </div>
            </div>

            <!-- Reset Button -->
            <button id="reset-button" class="mt-8 px-6 py-2 bg-indigo-600 text-white font-bold rounded-full shadow-lg hover:bg-indigo-500 transition duration-200 active:scale-95 flex items-center">
                <i data-lucide="rotate-ccw" class="w-5 h-5 mr-2"></i>
                Restart Game
            </button>
        </div>

        <!-- Message Box for Alerts (replacing alert()) -->
        <div id="message-box" class="fixed inset-0 bg-black bg-opacity-70 backdrop-blur-sm items-center justify-center hidden z-50">
            <div class="bg-white p-6 rounded-xl shadow-2xl max-w-xs w-full text-center transform scale-100 transition-all duration-300">
                <h3 id="message-title" class="text-xl font-bold mb-2 text-gray-800">Game Over!</h3>
                <p id="message-text" class="text-gray-600 mb-4">It's a draw!</p>
                <button id="close-message" class="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-500 transition">Play Again</button>
            </div>
        </div>

    </div>

    <script>
        // Game State Variables
        let board;
        let currentPlayer;
        let gameActive;
        let playerNames = { 'X': 'Player X', 'O': 'Player O' };

        // DOM Elements
        const setupScreenEl = document.getElementById('setup-screen');
        const gameScreenEl = document.getElementById('game-screen');
        const player1NameInput = document.getElementById('player1-name');
        const player2NameInput = document.getElementById('player2-name');
        const startGameButton = document.getElementById('start-game-button');
        
        const gameBoardEl = document.getElementById('game-board');
        const statusMessageEl = document.getElementById('status-message');
        const resetButton = document.getElementById('reset-button');
        const winLineEl = document.getElementById('win-line');
        const messageBox = document.getElementById('message-box');
        const messageTitle = document.getElementById('message-title');
        const messageText = document.getElementById('message-text');
        const closeMessageButton = document.getElementById('close-message');

        /**
         * Hides the setup screen and shows the game screen, then starts the game.
         */
        function startGame() {
            // Get names from inputs, defaulting if empty
            playerNames['X'] = player1NameInput.value.trim() || 'Player X';
            playerNames['O'] = player2NameInput.value.trim() || 'Player O';

            setupScreenEl.classList.add('hidden');
            gameScreenEl.classList.remove('hidden');

            // Now that names are set, initialize the board
            initializeGame();
        }

        /**
         * Initializes the game state and board.
         * Corresponds to the Game constructor and initializeBoard methods in C++.
         */
        function initializeGame() {
            board = [
                ['', '', ''],
                ['', '', ''],
                ['', '', '']
            ];
            currentPlayer = 'X';
            gameActive = true;
            renderBoard();
            updateStatusMessage();
            hideWinLine();
        }

        /**
         * Renders the HTML grid based on the current board state.
         */
        function renderBoard() {
            gameBoardEl.innerHTML = '';
            for (let r = 0; r < 3; r++) {
                for (let c = 0; c < 3; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell', 'rounded-lg');
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    cell.textContent = board[r][c];
                    
                    if (board[r][c] !== '') {
                        cell.classList.add('occupied');
                        // Add class for styling X or O
                        cell.classList.add(board[r][c] === 'X' ? 'text-indigo-400' : 'text-yellow-400');
                    } else {
                        // Only add click listener to empty cells
                        cell.addEventListener('click', handleCellClick);
                    }
                    gameBoardEl.appendChild(cell);
                }
            }
            // Re-render icons after board update
            lucide.createIcons();
        }

        /**
         * Updates the status message displayed to the user using player names.
         */
        function updateStatusMessage() {
            const playerName = playerNames[currentPlayer];
            const playerSymbolColor = currentPlayer === 'X' ? 'text-indigo-400' : 'text-yellow-400';
            
            statusMessageEl.innerHTML = `<span class="text-gray-300">${playerName}'s Turn (<span class="${playerSymbolColor}">${currentPlayer}</span>)</span>`;
        }

        /**
         * Handles a click on a board cell.
         * Corresponds to the main game loop logic in main.cpp.
         */
        function handleCellClick(event) {
            if (!gameActive) return;

            const row = parseInt(event.target.dataset.row);
            const col = parseInt(event.target.dataset.col);
            const currentPlayerName = playerNames[currentPlayer];

            // Attempt to make the move (makeMove in C++)
            if (makeMove(row, col)) {
                // Move was successful
                renderBoard();

                if (checkWin()) {
                    gameActive = false;
                    const winningCombo = getWinningCombo();
                    drawWinLine(winningCombo);
                    
                    const playerSymbolColor = currentPlayer === 'X' ? 'text-indigo-400' : 'text-yellow-400';
                    const messageTitleHtml = `<span class="${playerSymbolColor}">${currentPlayerName} (${currentPlayer})</span> Wins!`;
                    
                    statusMessageEl.innerHTML = messageTitleHtml;
                    showMessageBox(messageTitleHtml, `Congratulations, ${currentPlayerName}! You won the game.`);
                    
                } else if (checkDraw()) {
                    gameActive = false;
                    statusMessageEl.innerHTML = '<span class="text-gray-300">It\'s a Draw!</span>';
                    showMessageBox('It\'s a Draw!', 'No moves left on the board.');
                } else {
                    // Switch player and update status
                    switchPlayer();
                    updateStatusMessage();
                }
            } else {
                // Invalid move - spot already taken
                console.warn('Invalid move: spot already taken.');
            }
        }

        /**
         * Core game logic to apply the move.
         * Corresponds to Game::makeMove in C++.
         */
        function makeMove(row, col) {
            // Check bounds (0-2) and check if the spot is empty
            if (row >= 0 && row < 3 && col >= 0 && col < 3 && board[row][col] === '') {
                board[row][col] = currentPlayer;
                return true;
            }
            return false;
        }

        /**
         * Checks for a win condition for the current player.
         * Corresponds to Game::checkWin in C++.
         */
        function checkWin() {
            return !!getWinningCombo();
        }

        /**
         * Returns the winning combination (an array of cell indices or null).
         * This function is needed for drawing the win line.
         */
        function getWinningCombo() {
            const lines = [
                // Rows
                [[0, 0], [0, 1], [0, 2]],
                [[1, 0], [1, 1], [1, 2]],
                [[2, 0], [2, 1], [2, 2]],
                // Columns
                [[0, 0], [1, 0], [2, 0]],
                [[0, 1], [1, 1], [2, 1]],
                [[0, 2], [1, 2], [2, 2]],
                // Diagonals
                [[0, 0], [1, 1], [2, 2]],
                [[0, 2], [1, 1], [2, 0]],
            ];

            for (let i = 0; i < lines.length; i++) {
                const [a, b, c] = lines[i];
                if (board[a[0]][a[1]] === currentPlayer &&
                    board[b[0]][b[1]] === currentPlayer &&
                    board[c[0]][c[1]] === currentPlayer) {
                    return { type: i, cells: lines[i] }; // Return the combination index and cells
                }
            }
            return null;
        }


        /**
         * Checks for a draw condition.
         * Corresponds to Game::checkDraw in C++.
         */
        function checkDraw() {
            for (let r = 0; r < 3; r++) {
                for (let c = 0; c < 3; c++) {
                    if (board[r][c] === '') {
                        return false; // Found an empty spot, not a draw
                    }
                }
            }
            return true; // No empty spots and no winner
        }

        /**
         * Switches the current player.
         * Corresponds to Game::switchPlayer in C++.
         */
        function switchPlayer() {
            currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
        }

        /**
         * Displays the game over message box.
         */
        function showMessageBox(title, text) {
            messageTitle.innerHTML = title;
            messageText.textContent = text;
            messageBox.classList.remove('hidden');
            messageBox.classList.add('flex');
        }

        /**
         * Hides the message box.
         * Note: Unlike the original C++ main loop, restarting here sends the user
         * back to the name input screen so they can change players if desired.
         */
        function hideMessageBox() {
            messageBox.classList.add('hidden');
            messageBox.classList.remove('flex');
            showSetupScreen();
        }

        /**
         * Displays the setup screen and hides the game screen.
         */
        function showSetupScreen() {
            gameScreenEl.classList.add('hidden');
            setupScreenEl.classList.remove('hidden');
            hideWinLine();
            // Ensure any cell highlights are removed
            const cellElements = gameBoardEl.children;
            Array.from(cellElements).forEach(cell => {
                cell.classList.remove('bg-red-900', 'bg-opacity-50', 'text-white', 'scale-105');
            });
        }

        /**
         * Hides the win line.
         */
        function hideWinLine() {
             winLineEl.classList.add('hidden-line');
             winLineEl.classList.remove('line-row', 'line-col', 'line-diag-ltr', 'line-diag-rtl');
             winLineEl.style.transform = '';
             winLineEl.style.top = '';
             winLineEl.style.left = '';
        }
        
        /**
         * Draws the visual line across the winning combination.
         */
        function drawWinLine(combo) {
            const boardRect = gameBoardEl.getBoundingClientRect();
            const cellElements = gameBoardEl.children;
            const firstCell = cellElements[combo.cells[0][0] * 3 + combo.cells[0][1]];
            const lastCell = cellElements[combo.cells[2][0] * 3 + combo.cells[2][1]];

            const firstRect = firstCell.getBoundingClientRect();
            const lastRect = lastCell.getBoundingClientRect();
            
            // Calculate center points of the first and last winning cells relative to the board
            const x1 = firstRect.left + firstRect.width / 2 - boardRect.left;
            const y1 = firstRect.top + firstRect.height / 2 - boardRect.top;
            const x2 = lastRect.left + lastRect.width / 2 - boardRect.left;
            const y2 = lastRect.top + lastRect.height / 2 - boardRect.top;

            // Calculate center, length, and angle
            const centerX = (x1 + x2) / 2;
            const centerY = (y1 + y2) / 2;
            const dx = x2 - x1;
            const dy = y2 - y1;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx) * (180 / Math.PI); // Angle in degrees

            winLineEl.classList.remove('hidden-line');
            winLineEl.style.width = `${distance * 1.05}px`; // Extend slightly
            winLineEl.style.top = `${centerY}px`;
            winLineEl.style.left = `${centerX}px`;
            winLineEl.style.transform = `translate(-50%, -50%) rotate(${angle}deg)`;
            
            // Highlight winning cells
            combo.cells.forEach(cellCoords => {
                const cellIndex = cellCoords[0] * 3 + cellCoords[1];
                cellElements[cellIndex].classList.add('bg-red-900', 'bg-opacity-50', 'scale-105');
                cellElements[cellIndex].style.transition = 'transform 0.3s ease-out, background-color 0.3s';
            });
        }


        // Event Listeners
        startGameButton.addEventListener('click', startGame);
        resetButton.addEventListener('click', showSetupScreen);
        closeMessageButton.addEventListener('click', hideMessageBox);


        // Initialization
        window.onload = showSetupScreen;
    </script>
</body>
</html>